<template>
  <section id="search-section" class="view">
    <div class="search-header">
      <!-- Search Filters moved to top -->
      <div class="search-filters old-filters" style="display: none;">
        <div class="filter-button-group">
          <button
            class="filter-btn"
            :class="{ active: everythingSelected }"
            @click="toggleEverything"
          >
            <span class="desktop-label">Search Everything</span>
            <span class="mobile-label">Everything</span>
          </button>
          <button
            class="filter-btn"
            :class="{ active: includeTypes.camps }"
            @click="toggleFilterType('camps')"
            :title="'Camps'"
          >
            <span class="desktop-label">üè† Camps</span>
            <span class="mobile-label">üè†</span>
          </button>
          <button
            class="filter-btn"
            :class="{ active: includeTypes.art }"
            @click="toggleFilterType('art')"
            :title="'Art'"
          >
            <span class="desktop-label">üé® Art</span>
            <span class="mobile-label">üé®</span>
          </button>
          <button
            class="filter-btn"
            :class="{ active: includeTypes.events }"
            @click="toggleFilterType('events')"
            :title="'Events'"
          >
            <span class="desktop-label">üéâ Events</span>
            <span class="mobile-label">üéâ</span>
          </button>
          <button
            class="filter-btn"
            :class="{ active: includeTypes.infrastructure }"
            @click="toggleFilterType('infrastructure')"
            :title="'Infrastructure'"
          >
            <span class="desktop-label">üèõÔ∏è Infra</span>
            <span class="mobile-label">üèõÔ∏è</span>
          </button>
          <button
            class="filter-btn"
            :class="{ active: includeTypes.notes }"
            @click="toggleFilterType('notes')"
            :title="'Notes'"
          >
            <span class="desktop-label">üìù Notes</span>
            <span class="mobile-label">üìù</span>
          </button>
        </div>
      </div>
      
      <!-- Mobile: Traditional stacked layout -->
      <div class="mobile-search-layout">
        <!-- Search Mode Selector (hidden - moved to collapsible) -->
        <div style="display: none;">
          <SearchModeSelector 
            v-model:selectedMode="searchMode"
            :isOnline="isOnline"
            :showDescription="showModeDescription"
            @modeChanged="onModeChanged"
          />
        </div>
        
        <div class="search-input-container">
          <input 
            v-model="searchQuery"
            @keydown.enter="performSearch"
            @keydown="handleKeyDown"
            type="text"
            :placeholder="searchPlaceholder"
            class="search-input"
            ref="searchInput"
          >
          
          <!-- Search Suggestions -->
          <SearchSuggestions
            :query="searchQuery"
            :isOnline="isOnline"
            :enabled="false"
            @select="onSuggestionSelect"
            @keydown="handleSuggestionKeyDown"
            ref="suggestionsRef"
          />
        </div>
      </div>
      
      <!-- Desktop: Unified search form group -->
      <div class="desktop-search-layout">
        <div class="unified-search-form">
          <!-- Mode buttons -->
          <div class="mode-buttons-inline">
            <button
              v-for="mode in availableModes"
              :key="mode.value"
              @click="selectMode(mode.value)"
              :class="[
                'mode-btn-inline',
                { 
                  'active': searchMode === mode.value,
                  'disabled': mode.disabled
                }
              ]"
              :disabled="mode.disabled"
              :title="mode.tooltip"
            >
              <span class="mode-icon">{{ mode.icon }}</span>
              <span class="mode-label">{{ mode.label }}</span>
            </button>
          </div>
          
          <!-- Search input -->
          <div class="search-input-wrapper">
            <input 
              v-model="searchQuery"
              @keydown.enter="performSearch"
              @keydown="handleKeyDown"
              type="text"
              :placeholder="searchPlaceholder"
              class="search-input-unified"
              ref="searchInputDesktop"
            >
            
            <!-- Search Suggestions -->
            <SearchSuggestions
              :query="searchQuery"
              :isOnline="isOnline"
              :enabled="false"
              @select="onSuggestionSelect"
              @keydown="handleSuggestionKeyDown"
              ref="suggestionsRefDesktop"
            />
          </div>
          
          <!-- Search/Clear button -->
          <button 
            class="search-action-btn"
            :class="{ disabled: !searchQuery }"
            :disabled="!searchQuery"
            @click="searchQuery ? clearSearch() : performSearch()"
            :title="searchQuery ? 'Clear search' : 'Search'"
          >
            {{ searchQuery ? 'Clear' : 'Search' }}
          </button>
        </div>
      </div>
      
      <!-- Collapsible Filters and Mode Controls -->
      <div class="search-options-container" :class="{ collapsed: isFiltersCollapsed }">
        <div class="options-header" @click="toggleFilters">
          <h4>Search Options</h4>
          <button 
            class="collapse-btn"
            :aria-label="isFiltersCollapsed ? 'Expand search options' : 'Collapse search options'"
          >
            {{ isFiltersCollapsed ? '‚ñº' : '‚ñ≤' }}
          </button>
        </div>
        
        <div v-show="!isFiltersCollapsed" class="options-content">
          <!-- Mobile Search Mode Selector (moved from above) -->
          <div class="mobile-mode-selector">
            <SearchModeSelector 
              v-model:selectedMode="searchMode"
              :isOnline="isOnline"
              :showDescription="showModeDescription"
              @modeChanged="onModeChanged"
            />
          </div>
          
          <!-- Search Filters (moved from above) -->
          <div class="search-filters-collapsible">
            <div class="filter-button-group">
              <button
                class="filter-btn"
                :class="{ active: everythingSelected }"
                @click="toggleEverything"
              >
                <span class="desktop-label">Search Everything</span>
                <span class="mobile-label">Everything</span>
              </button>
              <button
                class="filter-btn"
                :class="{ active: includeTypes.camps }"
                @click="toggleFilterType('camps')"
                :title="'Camps'"
              >
                <span class="desktop-label">üè† Camps</span>
                <span class="mobile-label">üè†</span>
              </button>
              <button
                class="filter-btn"
                :class="{ active: includeTypes.art }"
                @click="toggleFilterType('art')"
                :title="'Art'"
              >
                <span class="desktop-label">üé® Art</span>
                <span class="mobile-label">üé®</span>
              </button>
              <button
                class="filter-btn"
                :class="{ active: includeTypes.events }"
                @click="toggleFilterType('events')"
                :title="'Events'"
              >
                <span class="desktop-label">üéâ Events</span>
                <span class="mobile-label">üéâ</span>
              </button>
              <button
                class="filter-btn"
                :class="{ active: includeTypes.infrastructure }"
                @click="toggleFilterType('infrastructure')"
                :title="'Infrastructure'"
              >
                <span class="desktop-label">üèõÔ∏è Infra</span>
                <span class="mobile-label">üèõÔ∏è</span>
              </button>
              <button
                class="filter-btn"
                :class="{ active: includeTypes.notes }"
                @click="toggleFilterType('notes')"
                :title="'Notes'"
              >
                <span class="desktop-label">üìù Notes</span>
                <span class="mobile-label">üìù</span>
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Search Status -->
      <div v-if="searchStatus" class="search-status">
        <span :class="searchStatusClass">{{ searchStatus }}</span>
      </div>
    </div>
    
    <div class="search-results">
      <div v-if="loading" class="search-loading">
        <div class="loading-spinner"></div>
        <span>{{ loadingMessage }}</span>
      </div>
      <div v-else-if="!searchQuery" class="hint">
        <div class="search-modes-info">
          <div class="mode-info">
            <span class="mode-icon">üîç</span>
            <div>
              <strong>Keyword Search</strong>
              <p>Fast text matching - works offline</p>
            </div>
          </div>
          <div v-if="isOnline" class="mode-info">
            <span class="mode-icon">üß†</span>
            <div>
              <strong>Semantic Search</strong>
              <p>AI understands meaning and context</p>
            </div>
          </div>
          <div v-if="isOnline" class="mode-info">
            <span class="mode-icon">üöÄ</span>
            <div>
              <strong>Smart Search</strong>
              <p>Best of both - hybrid results</p>
            </div>
          </div>
        </div>
        <p>Start typing to search across all camps, art installations, and events</p>
      </div>
      <div v-else-if="results.length === 0 && !loading" class="no-results">
        <div class="no-results-content">
          <h3>No results found for "{{ searchQuery }}"</h3>
          <div class="search-suggestions-help">
            <p v-if="searchMode === 'keyword'">Try:</p>
            <p v-else>Try switching search modes or:</p>
            <ul>
              <li v-if="searchMode !== 'semantic' && isOnline">Using <strong>Semantic search</strong> to find by meaning</li>
              <li>Different keywords or phrases</li>
              <li>Checking your spelling</li>
              <li>Using more general terms</li>
            </ul>
          </div>
        </div>
      </div>
      <div v-else class="results-list">
        <div class="results-header">
          <div class="results-count">
            {{ results.length }} result{{ results.length !== 1 ? 's' : '' }} found
            <span v-if="totalItemsSearched > 0" class="total-searched">
              (searched {{ totalItemsSearched.toLocaleString() }} items)
            </span>
            <span v-if="searchExecutionTime" class="execution-time">
              {{ searchExecutionTime }}ms{{ fromCache ? ', cached' : '' }}
            </span>
          </div>
          <div v-if="searchMode !== 'keyword'" class="search-mode-badge">
            {{ searchModeLabels[searchMode] }}
          </div>
        </div>
        
        <SearchResultItem
          v-for="result in paginatedResults"
          :key="`${result.type}-${result.item.uid}`"
          :result="result"
          :searchMode="searchMode"
          :showSimilarityScore="searchMode !== 'keyword'"
          @navigate="navigateToItem"
          @toggleFavorite="toggleFavorite"
        />
        
        <div v-if="hasMore" class="load-more">
          <button @click="loadMore" class="load-more-btn">
            Load More Results
          </button>
        </div>
      </div>
    </div>
  </section>
</template>

<script setup>
import { ref, reactive, computed, onMounted, watch, nextTick } from 'vue'
import { useRouter, useRoute } from 'vue-router'
import { getFromCache } from '../services/storage.js'
import { isFavorite, toggleFavorite as toggleFav } from '../services/favorites.js'
import { getItemName, getItemLocation } from '../utils.js'
import { getItemNotes } from '../services/visits.js'
import SearchModeSelector from '../components/search/SearchModeSelector.vue'
import SearchResultItem from '../components/search/SearchResultItem.vue'
import SearchSuggestions from '../components/search/SearchSuggestions.vue'
import { getAllInfrastructure, searchInfrastructure } from '../services/infrastructure.js'
import { 
  vectorSearch, 
  hybridSearch, 
  entitySearch,
  isVectorSearchAvailable,
  searchPreferences
} from '../services/vectorSearchService.js'

const router = useRouter()
const route = useRoute()

// Reactive state
const searchQuery = ref('')
const searchMode = ref('keyword')
const loading = ref(false)
const loadingMessage = ref('Searching...')
const results = ref([])
const currentPage = ref(1)
const pageSize = 20
const year = ref(route.params.year || localStorage.getItem('selectedYear') || '2025')
const isOnline = ref(navigator.onLine)
const searchStatus = ref('')
const searchExecutionTime = ref(null)
const fromCache = ref(false)
const showSuggestions = ref(true)
const showModeDescription = ref(false)
const totalItemsSearched = ref(0)

const includeTypes = reactive({
  camps: true,
  art: true,
  events: true,
  infrastructure: true,
  notes: true
})

// Collapsible state for filters
const isFiltersCollapsed = ref(false)

const typeIcons = {
  camp: 'üè†',
  art: 'üé®',
  event: 'üéâ',
  infrastructure: 'üèõÔ∏è'
}

const searchModeLabels = {
  semantic: 'AI Search',
  smart: 'Smart Search',
  keyword: 'Keyword'
}

// Refs for components
const searchInput = ref(null)
const suggestionsRef = ref(null)
const searchInputDesktop = ref(null)
const suggestionsRefDesktop = ref(null)

// Computed properties
const paginatedResults = computed(() => {
  const end = currentPage.value * pageSize
  return results.value.slice(0, end)
})

const hasMore = computed(() => {
  return results.value.length > currentPage.value * pageSize
})

const searchStatusClass = computed(() => {
  if (searchStatus.value.includes('offline')) return 'status-offline'
  if (searchStatus.value.includes('error')) return 'status-error'
  if (searchStatus.value.includes('cached')) return 'status-cached'
  return 'status-online'
})

const selectedTypes = computed(() => {
  const types = []
  if (includeTypes.camps) types.push('camp')
  if (includeTypes.art) types.push('art')
  if (includeTypes.events) types.push('event')
  if (includeTypes.infrastructure) types.push('infrastructure')
  if (includeTypes.notes) types.push('notes')
  return types
})

// Check if all filter types are selected
const everythingSelected = computed(() => {
  return includeTypes.camps && 
         includeTypes.art && 
         includeTypes.events && 
         includeTypes.infrastructure && 
         includeTypes.notes
})

// Dynamic placeholder based on selected filters
const searchPlaceholder = computed(() => {
  const selected = []
  if (includeTypes.camps) selected.push('camps')
  if (includeTypes.art) selected.push('art')
  if (includeTypes.events) selected.push('events')
  if (includeTypes.infrastructure) selected.push('infra')
  if (includeTypes.notes) selected.push('notes')
  
  if (selected.length === 0) {
    return 'Select a filter to search...'
  } else if (selected.length === 5) {
    return 'Search everything...'
  } else if (selected.length === 1) {
    return `Search ${selected[0]}...`
  } else if (selected.length === 2) {
    return `Search ${selected[0]} and ${selected[1]}...`
  } else {
    // 3 or more items: "camps, art, and events"
    const lastItem = selected.pop()
    return `Search ${selected.join(', ')}, and ${lastItem}...`
  }
})

// Available search modes for desktop inline buttons
const availableModes = computed(() => {
  const modes = [
    {
      value: 'keyword',
      label: 'Keyword',
      icon: 'üîç',
      tooltip: 'Traditional keyword search (always available)',
      disabled: false
    },
    {
      value: 'semantic',
      label: 'Semantic', 
      icon: 'üß†',
      tooltip: 'Find results by meaning, not just keywords (requires internet)',
      disabled: !isOnline.value
    },
    {
      value: 'smart',
      label: 'Smart',
      icon: 'üöÄ',
      tooltip: 'Hybrid search for best results (requires internet)', 
      disabled: !isOnline.value
    }
  ]
  return modes
})

// Watch for online status changes
watch(() => navigator.onLine, (online) => {
  isOnline.value = online
  if (!online && searchMode.value !== 'keyword') {
    searchStatus.value = 'Switched to keyword search (offline)'
    searchMode.value = 'keyword'
    performSearch()
  }
})

// Update URL with search parameters
function updateURL() {
  const query = {}
  
  if (searchQuery.value) {
    query.q = searchQuery.value
  }
  
  if (searchMode.value && searchMode.value !== 'keyword') {
    query.mode = searchMode.value
  }
  
  // Update URL without triggering navigation
  router.replace({
    name: 'search',
    params: { year: year.value },
    query
  })
}

// Save filter preferences to localStorage
const saveFilterPreferences = () => {
  const filterPrefs = {
    camps: includeTypes.camps,
    art: includeTypes.art,
    events: includeTypes.events,
    infrastructure: includeTypes.infrastructure,
    notes: includeTypes.notes
  }
  localStorage.setItem('search_filter_preferences', JSON.stringify(filterPrefs))
}

// Load filter preferences from localStorage
const loadFilterPreferences = () => {
  const saved = localStorage.getItem('search_filter_preferences')
  if (saved) {
    try {
      const prefs = JSON.parse(saved)
      includeTypes.camps = prefs.camps !== false
      includeTypes.art = prefs.art !== false
      includeTypes.events = prefs.events !== false
      includeTypes.infrastructure = prefs.infrastructure !== false
      includeTypes.notes = prefs.notes !== false
    } catch (e) {
      console.error('Error loading filter preferences:', e)
    }
  }
}

// Initialize component
onMounted(async () => {
  // Load filter preferences
  loadFilterPreferences()
  
  // Load collapsed state
  const savedCollapsed = localStorage.getItem('searchFiltersCollapsed')
  if (savedCollapsed !== null) {
    isFiltersCollapsed.value = savedCollapsed === 'true'
  }
  
  // Check for URL parameters first
  if (route.query.q) {
    searchQuery.value = route.query.q
  }
  
  if (route.query.mode && ['keyword', 'semantic', 'smart'].includes(route.query.mode)) {
    searchMode.value = route.query.mode
  } else {
    // Load user preferences if no mode in URL
    const prefs = searchPreferences.get()
    searchMode.value = prefs.defaultMode || 'keyword'
  }
  
  showSuggestions.value = searchPreferences.get().enableSemanticSearch !== false
  
  // Check if vector search is available
  if (isOnline.value) {
    const available = await isVectorSearchAvailable()
    if (!available) {
      searchStatus.value = 'AI search temporarily unavailable'
    }
  }
  
  // If we have a query from URL, perform search
  if (searchQuery.value) {
    await performSearch()
  } else {
    // Focus search input if no query
    nextTick(() => {
      // Try desktop input first, then mobile
      if (searchInputDesktop.value) {
        searchInputDesktop.value.focus()
      } else if (searchInput.value) {
        searchInput.value.focus()
      }
    })
  }
})

// Search is now triggered only on Enter key
// Removed debounced search-as-you-type functionality

// Keyboard handling
const handleKeyDown = (event) => {
  if (suggestionsRef.value) {
    suggestionsRef.value.handleKeyDown(event)
  }
}

const handleSuggestionKeyDown = (event) => {
  // Handle any additional keyboard events from suggestions
}

// Search mode change handler
const onModeChanged = (data) => {
  const { mode } = data
  
  // If everything is selected and user changes mode, deselect all filters
  if (everythingSelected.value) {
    includeTypes.camps = false
    includeTypes.art = false
    includeTypes.events = false
    includeTypes.infrastructure = false
    includeTypes.notes = false
    saveFilterPreferences()
  }
  
  // Save preference
  const prefs = searchPreferences.get()
  prefs.defaultMode = mode
  searchPreferences.set(prefs)
  
  // Update URL to reflect mode change
  updateURL()
  
  // Re-run search if we have a query or results
  if (searchQuery.value || results.value.length > 0) {
    performSearch()
  }
  
  // Update status
  if (mode !== 'keyword' && !isOnline.value) {
    searchStatus.value = 'This search mode requires internet connection'
  } else {
    searchStatus.value = ''
  }
}

// Select search mode (for desktop inline buttons)
const selectMode = (mode) => {
  if (availableModes.value.find(m => m.value === mode)?.disabled) return
  
  searchMode.value = mode
  
  // Save preference
  const prefs = searchPreferences.get()
  prefs.defaultMode = mode
  searchPreferences.set(prefs)
  
  // Update URL to reflect mode change
  updateURL()
  
  // Re-run search if we have a query or results
  if (searchQuery.value || results.value.length > 0) {
    performSearch()
  }
  
  // Update status
  if (mode !== 'keyword' && !isOnline.value) {
    searchStatus.value = 'This search mode requires internet connection'
  } else {
    searchStatus.value = ''
  }
}

// Clear search
const clearSearch = () => {
  searchQuery.value = ''
  results.value = []
  searchStatus.value = ''
  totalItemsSearched.value = 0
  updateURL() // Clear URL when search is cleared
  
  // Focus the search input
  nextTick(() => {
    const input = searchInputDesktop.value || searchInput.value
    if (input) {
      input.focus()
    }
  })
}

// Toggle filter type
const toggleFilterType = (type) => {
  // If everything is currently selected, clicking a filter should select only that one
  if (everythingSelected.value) {
    // Deselect all
    includeTypes.camps = false
    includeTypes.art = false
    includeTypes.events = false
    includeTypes.infrastructure = false
    includeTypes.notes = false
    // Select only the clicked one
    includeTypes[type] = true
  } else {
    // Normal toggle behavior
    includeTypes[type] = !includeTypes[type]
  }
  
  saveFilterPreferences()
  
  // Re-run search if we have results or a query
  if (searchQuery.value || results.value.length > 0) {
    performSearch()
  }
}

// Toggle everything on/off
const toggleEverything = () => {
  if (everythingSelected.value) {
    // If everything is selected, deselect all
    includeTypes.camps = false
    includeTypes.art = false
    includeTypes.events = false
    includeTypes.infrastructure = false
    includeTypes.notes = false
  } else {
    // If not everything is selected, select all
    includeTypes.camps = true
    includeTypes.art = true
    includeTypes.events = true
    includeTypes.infrastructure = true
    includeTypes.notes = true
  }
  
  saveFilterPreferences()
  
  // Re-run search if we have results or a query
  if (searchQuery.value || results.value.length > 0) {
    performSearch()
  }
}

// Toggle filters visibility
const toggleFilters = () => {
  isFiltersCollapsed.value = !isFiltersCollapsed.value
  localStorage.setItem('searchFiltersCollapsed', isFiltersCollapsed.value.toString())
}

// Suggestion selection
const onSuggestionSelect = (suggestion) => {
  searchQuery.value = suggestion
  performSearch()
}

// Main search function
const performSearch = async () => {
  if (!searchQuery.value.trim()) {
    results.value = []
    searchStatus.value = ''
    updateURL() // Clear URL when search is cleared
    return
  }
  
  loading.value = true
  loadingMessage.value = getLoadingMessage()
  currentPage.value = 1
  searchExecutionTime.value = null
  fromCache.value = false
  
  // Update URL with current search state
  updateURL()
  
  try {
    let searchResults = []
    
    if (searchMode.value === 'keyword' || !isOnline.value) {
      // Keyword search (existing logic)
      searchResults = await performKeywordSearch()
      searchStatus.value = isOnline.value ? '' : 'Offline - using keyword search'
    } else {
      // Vector/semantic search
      searchResults = await performVectorSearch()
    }
    
    results.value = searchResults
  } catch (error) {
    console.error('Search error:', error)
    searchStatus.value = `Search error: ${error.message}`
    
    // Fallback to keyword search on error
    if (searchMode.value !== 'keyword') {
      searchStatus.value += ' - falling back to keyword search'
      try {
        results.value = await performKeywordSearch()
      } catch (fallbackError) {
        results.value = []
      }
    }
  } finally {
    loading.value = false
  }
}

const getLoadingMessage = () => {
  switch (searchMode.value) {
    case 'semantic':
      return 'AI is understanding your search...'
    case 'smart':
      return 'Finding the best results...'
    default:
      return 'Searching...'
  }
}

// Keyword search (existing logic)
const performKeywordSearch = async () => {
  const query = searchQuery.value.toLowerCase()
  const searchResults = []
  let itemsSearched = 0
  
  // Search camps
  if (includeTypes.camps) {
    const camps = await getFromCache('camp', parseInt(year.value) || 2024)
    if (camps) {
      itemsSearched += camps.length
      camps.forEach(camp => {
        if (matchesSearch(camp, query)) {
          searchResults.push({
            type: 'camp',
            item: camp,
            isFavorited: isFavorite('camp', camp.uid)
          })
        }
      })
    }
  }
  
  // Search art
  if (includeTypes.art) {
    const art = await getFromCache('art', parseInt(year.value) || 2024)
    if (art) {
      itemsSearched += art.length
      art.forEach(artPiece => {
        if (matchesSearch(artPiece, query)) {
          searchResults.push({
            type: 'art',
            item: artPiece,
            isFavorited: isFavorite('art', artPiece.uid)
          })
        }
      })
    }
  }
  
  // Search events
  if (includeTypes.events) {
    const events = await getFromCache('event', parseInt(year.value) || 2024)
    if (events) {
      itemsSearched += events.length
      events.forEach(event => {
        if (matchesSearch(event, query)) {
          searchResults.push({
            type: 'event',
            item: event,
            isFavorited: isFavorite('event', event.uid)
          })
        }
      })
    }
  }
  
  // Search infrastructure
  if (includeTypes.infrastructure) {
    const infrastructure = getAllInfrastructure()
    if (infrastructure) {
      itemsSearched += infrastructure.length
      infrastructure.forEach(infraItem => {
        if (matchesInfrastructureSearch(infraItem, query)) {
          searchResults.push({
            type: 'infrastructure',
            item: infraItem,
            isFavorited: false // Infrastructure doesn't use favorites currently
          })
        }
      })
    }
  }
  
  // Sort by relevance (name matches first)
  searchResults.sort((a, b) => {
    const aName = getItemName(a.item).toLowerCase()
    const bName = getItemName(b.item).toLowerCase()
    const aNameMatch = aName.includes(query)
    const bNameMatch = bName.includes(query)
    
    if (aNameMatch && !bNameMatch) return -1
    if (!aNameMatch && bNameMatch) return 1
    
    return aName.localeCompare(bName)
  })
  
  // Update total items searched
  totalItemsSearched.value = itemsSearched
  
  return searchResults
}

// Vector search implementation
const performVectorSearch = async () => {
  const searchOptions = {
    year: parseInt(year.value) || 2024,
    types: selectedTypes.value,
    limit: 50 // Get more results for better ranking
  }
  
  let apiResults
  
  try {
    if (searchMode.value === 'semantic') {
      apiResults = await vectorSearch(searchQuery.value, searchOptions)
    } else if (searchMode.value === 'smart') {
      apiResults = await hybridSearch(searchQuery.value, searchOptions)
    }
    
    // Update execution time and cache status
    searchExecutionTime.value = apiResults.meta?.execution_time || null
    fromCache.value = apiResults.fromCache || false
    
    // Update total items searched from API meta if available
    if (apiResults.meta?.total_searched) {
      totalItemsSearched.value = apiResults.meta.total_searched
    }
    
    // Convert API results to our format
    const searchResults = apiResults.results.map(result => ({
      type: result.type,
      item: {
        uid: result.uid,
        name: result.name,
        description: result.description,
        ...result.metadata
      },
      similarity_score: result.similarity_score,
      entities: result.entities,
      isFavorited: isFavorite(result.type, result.uid)
    }))
    
    searchStatus.value = ''
    
    return searchResults
  } catch (error) {
    throw error
  }
}

// Existing keyword matching function
const matchesSearch = (item, query) => {
  const name = getItemName(item).toLowerCase()
  const location = getItemLocation(item).toLowerCase()
  const description = (item.description || '').toLowerCase()
  const hometown = (item.hometown || '').toLowerCase()
  
  // Check personal notes for this item
  const itemType = item.occurrence_set ? 'event' : item.artist ? 'art' : 'camp'
  const notes = getItemNotes(itemType, item.uid, year.value).toLowerCase()
  
  return name.includes(query) || 
         location.includes(query) || 
         description.includes(query) ||
         hometown.includes(query) ||
         notes.includes(query)
}

// Infrastructure-specific search function
const matchesInfrastructureSearch = (item, query) => {
  const name = (item.name || '').toLowerCase()
  const shortDescription = (item.shortDescription || '').toLowerCase()
  const category = (item.category || '').toLowerCase()
  const history = (item.history || '').toLowerCase()
  const civicPurpose = (item.civicPurpose || '').toLowerCase()
  const operations = (item.operations || '').toLowerCase()
  
  return name.includes(query) ||
         shortDescription.includes(query) ||
         category.includes(query) ||
         history.includes(query) ||
         civicPurpose.includes(query) ||
         operations.includes(query)
}

// Navigation and interaction
const navigateToItem = (result) => {
  // Use the correct route pattern from other views
  if (result.type === 'infrastructure') {
    router.push(`/${year.value}/infrastructure/${result.item.id}`)
  } else {
    router.push(`/${year.value}/${result.type}s/${result.item.uid}`)
  }
}

const toggleFavorite = (result) => {
  const newState = toggleFav(result.type, result.item.uid)
  result.isFavorited = newState
}

const loadMore = () => {
  currentPage.value++
}
</script>

<style scoped>
.view {
  padding: 1rem;
  color: #f0f0f0;
  background: #1a1a1a;
  min-height: 100vh;
  box-sizing: border-box;
  width: 100%;
  max-width: 1000px;
  margin: 0 auto;
  overflow-x: hidden;
}

.search-header {
  margin-bottom: 1rem;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  overflow-x: hidden;
}

.search-header h2 {
  margin: 0 0 1rem 0;
  color: #fff;
}

.search-input-container {
  position: relative;
  margin-bottom: 0.5rem;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

.search-input {
  width: 100%;
  padding: 0.75rem;
  font-size: 1.1rem;
  background: #2a2a2a;
  color: #fff;
  border: 1px solid #444;
  border-radius: 8px;
  transition: all 0.2s ease;
  box-sizing: border-box;
  max-width: 100%;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
}

.search-input:focus {
  outline: none;
  border-color: #680000 !important;
  box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.4), 0 0 0 2px rgba(104, 0, 0, 0.2);
}

.search-status {
  margin-top: 0.5rem;
  font-size: 0.9rem;
}

.status-offline {
  color: #ff9800;
}

.status-error {
  color: #f44336;
}

.status-cached {
  color: #4caf50;
}

.status-online {
  color: var(--color-dark-red);
}

.search-filters {
  display: flex;
  gap: 1rem;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
}

.filter-checkbox {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: #ccc;
  cursor: pointer;
  transition: color 0.2s ease;
}

.filter-checkbox:hover {
  color: var(--color-dark-red);
}

.filter-checkbox input {
  cursor: pointer;
}

.search-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  text-align: center;
  color: #999;
  padding: 1rem 0;
}

.loading-spinner {
  width: 32px;
  height: 32px;
  border: 3px solid #333;
  border-top: 3px solid #680000;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.hint {
  text-align: center;
  color: #999;
  padding: 1rem 0;
}

.search-modes-info {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin: 0 0 1rem 0;
}

.mode-info {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1.25rem;
  background: #2a2a2a;
  border-radius: 8px;
  border: 1px solid #444;
  transition: all 0.2s ease;
}

@media (min-width: 601px) {
  .mode-info:hover {
    border-color: #680000 !important;
    background: rgba(104, 0, 0, 0.1);
  }
}

.mode-icon {
  font-size: 2rem;
  flex-shrink: 0;
}

.mode-info strong {
  color: #fff;
  display: block;
  margin-bottom: 0.25rem;
  font-size: 1.1rem;
  font-weight: 600;
}

.mode-info p {
  margin: 0;
  font-size: 0.875rem;
  color: #999;
  line-height: 1.3;
}

.no-results {
  text-align: center;
  color: #999;
  padding: 1rem 0;
}

.no-results-content h3 {
  color: #fff;
  margin-bottom: 1rem;
}

.search-suggestions-help {
  text-align: left;
  max-width: 400px;
  margin: 0 auto;
}

.search-suggestions-help ul {
  margin: 0.5rem 0;
  padding-left: 1.5rem;
}

.search-suggestions-help li {
  margin: 0.25rem 0;
}

.results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.results-count {
  color: #999;
  font-size: 0.9rem;
}

.execution-time {
  color: #666;
  font-size: 0.8rem;
}

.total-searched {
  color: #888;
  font-size: 0.9rem;
  margin: 0 0.5rem;
}

.search-mode-badge {
  background: var(--color-dark-red);
  color: white;
  padding: 0.25rem 0.5rem;
  border-radius: 12px;
  font-size: 0.8rem;
  font-weight: bold;
  display: none;
}

.results-list {
  background: #2a2a2a;
  border-radius: 8px;
  padding: 1rem;
  margin-top: 1rem;
}

.load-more {
  text-align: center;
  margin-top: 1rem;
}

.load-more-btn {
  background: var(--color-dark-red);
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s ease;
  text-transform: uppercase;
}

.load-more-btn:hover {
  background: var(--color-dark-red-original);
}

/* Desktop/Mobile layout switching */
.mobile-search-layout {
  display: block;
}

.desktop-search-layout {
  display: none;
}

@media (min-width: 601px) {
  .mobile-search-layout {
    display: none;
  }
  
  .desktop-search-layout {
    display: block;
  }
}

/* Desktop unified search form */
.unified-search-form {
  display: flex;
  align-items: stretch;
  background: #333;
  border: 1px solid #555;
  border-radius: 8px;
  overflow: hidden;
}

.mode-buttons-inline {
  display: flex;
  border-right: 1px solid #555;
}

.mode-btn-inline {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  border-right: 1px solid #555;
  color: #ccc;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
  font-size: 0.9rem;
}

.mode-btn-inline:last-child {
  border-right: none;
}

.mode-btn-inline:hover:not(.disabled) {
  background: #444;
  color: #fff;
}

.mode-btn-inline.active {
  background: var(--color-dark-red);
  color: #fff;
}

.mode-btn-inline.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.mode-btn-inline .mode-icon {
  font-size: 1rem;
}

.mode-btn-inline .mode-label {
  font-size: 0.9rem;
  font-weight: 500;
}

.search-input-wrapper {
  flex: 1;
  position: relative;
}

.search-input-unified {
  width: 100%;
  padding: 0.75rem 1rem;
  background: transparent;
  border: none;
  color: #fff;
  font-size: 1rem;
  outline: none;
  height: 100%;
  display: flex;
  align-items: center;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
  transition: box-shadow 0.2s ease;
}

.search-input-unified::placeholder {
  color: #999;
}

.search-input-unified:focus {
  box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3);
}

.search-action-btn {
  padding: 0.75rem 1.5rem;
  background: var(--color-dark-red);
  border: none;
  border-left: 1px solid #555;
  color: #fff;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 500;
  text-transform: uppercase;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.search-action-btn:hover:not(.disabled) {
  background: #a50000;
}

.search-action-btn.disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background: #666;
}

/* Collapsible Search Options - matching infrastructure-intro style */
.search-options-container {
  margin: 1rem auto;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  border: 1px solid #444;
  max-width: 100%;
  overflow: hidden;
}

.search-options-container.collapsed .options-header {
  border-radius: 8px;
  border-bottom: none;
}

.options-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  background: rgba(0, 0, 0, 0.3);
  border-bottom: 1px solid #444;
  cursor: pointer;
  transition: background 0.2s ease;
}

.options-header:hover {
  background: rgba(0, 0, 0, 0.4);
}

.options-header h4 {
  margin: 0;
  color: var(--color-gold);
  font-size: 0.8rem;
  text-transform: uppercase;
  letter-spacing: 0.02em;
  line-height: 1.3;
}

.options-header .collapse-btn {
  background: none;
  border: none;
  color: #ccc;
  font-size: 0.875rem;
  cursor: pointer;
  padding: 0.25rem 0.5rem;
  margin-left: 0.5rem;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.options-header .collapse-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
}

.options-content {
  padding: 1rem;
}

.mobile-mode-selector {
  display: none;
}

.search-filters-collapsible {
  display: flex;
  justify-content: flex-start;
  width: 100%;
}

/* Mobile: Show mode selector in collapsible */
@media (max-width: 600px) {
  .mobile-mode-selector {
    display: block;
    margin-bottom: 1rem;
  }
  
  .search-options-container {
    margin: 0.5rem 0;
  }
  
  .options-header {
    padding: 0.625rem 0.75rem;
  }
  
  .options-header h4 {
    font-size: 0.75rem;
    padding-right: 0.5rem;
  }
  
  .options-header .collapse-btn {
    font-size: 0.75rem;
    padding: 0.125rem 0.25rem;
    flex-shrink: 0;
  }
  
  .options-content {
    padding: 0.75rem;
  }
}

/* Search Filters Button Group */
.search-filters {
  display: flex;
  justify-content: flex-start;
  margin-bottom: 0.75rem;
  width: 100%;
}

.filter-button-group {
  display: flex;
  background: #333;
  border: 1px solid #555;
  border-radius: 8px;
  overflow: hidden;
  width: 100%;
}

.filter-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.375rem;
  padding: 0.875rem 1rem;
  background: none;
  border: none;
  border-right: 1px solid #555;
  color: #ccc;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
  font-size: 0.875rem;
  min-height: 44px;
  flex: 1;
  text-transform: uppercase;
}

.filter-btn:first-child {
  flex: 1.5;
}

.filter-btn:last-child {
  border-right: none;
}

.filter-btn:hover:not(.active) {
  background: #444;
  color: #fff;
}

.filter-btn.active {
  background: var(--color-dark-red);
  color: #fff;
}

/* Show/hide labels based on screen size */
.desktop-label {
  display: inline;
}

.mobile-label {
  display: none;
}

@media (max-width: 600px) {
  .desktop-label {
    display: none;
  }
  
  .mobile-label {
    display: inline;
  }
}

/* Mobile optimizations */
@media (max-width: 600px) {
  .view {
    padding: 0.75rem;
  }
  
  .search-header {
    margin-bottom: 0.75rem;
  }
  
  .filter-button-group {
    flex-wrap: nowrap;
    border-radius: 8px;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  
  .filter-btn {
    flex: 1;
    width: auto;
    min-width: 44px;
    padding: 0;
    border-right: 1px solid #555;
    border-bottom: none;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .filter-btn:first-child {
    flex: 2;
    padding: 0.75rem 1rem;
  }
  
  .filter-btn:last-child {
    border-right: none;
  }
  
  .search-modes-info {
    grid-template-columns: 1fr;
    gap: 0.5rem;
  }
  
  .mode-info {
    padding: 0.75rem;
  }
  
  .results-header {
    flex-direction: column;
    align-items: flex-start;
  }
}
</style>